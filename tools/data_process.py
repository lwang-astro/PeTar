#!/usr/bin/env python3

import numpy as np
import multiprocessing as mp
import sys
import os
import petar
import getopt

if __name__ == '__main__':

    filename_prefix='data'
    average_mode='sphere'
    read_flag=False
    ftid_file_flag=False
    n_cpu=0
    write_option='w'
    snapshot_format='ascii'
    esc_snapshot_format='ascii'
    output_format='ascii'

    def usage():
        print("A tool for post-data processing of a list of snapshot files from petar.")
        print("Functionality:")
        print("   1) Generate new snapshots of singles, binaries, and optionally triples/quadruples for each snapshot file.")
        print("   2) Calculate the density center, core radius, and Lagrangian properties based on the density center, including")
        print("      radii and the corresponding properties inside each radius: number of objects, average masses, mean velocities, and velocity dispersions.")
        print("      Binaries are treated as single objects using their center of the mass.")
        print("   3) Identify single and binary escapers and save them into files.")
        print("Usage: petar.data.process [options] [snapshot path list filename]")
        print("   snapshot path list file: A list of snapshot data paths, each line for one snapshot.")
        print("                            This file can be generated by petar.data.gether.")
        print("Options (default arguments shown in parentheses at the end):")
        print("  -h(--help)                Display help information.")
        print("  -p(--filename-prefix) [S] Prefix of output file names as: [prefix].[lagr|esc_[single|binary]|core] (default: data).")
        print("  -m(--mass-fraction)   [S] Lagrangian radii mass fraction, seperated by ',' without empty spaces (default: 0.1,0.3,0.5,0.7,0.9).")
        print("  -G(--gravitational-constant) [F] Gravitational constant (if interrupt-mode=(mo)bse: "+str(petar.G_MSUN_PC_MYR)+"; else 1.0).")
        print("  -b(--r-max-binary)    [F] Maximum separation for detecting binaries (default: 0.1).")
        print("  -B(--full-binary)         Calculate detailed binary orbital parameters (including orbital angle and phase) with time-consuming computation;")
        print("                            Without this option, only basic orbital parameters (semi-major axis and eccentricity) are calculated.")
        print("  -M(--multiple)            Detect multiple systems (binaries, triples, and quadruples) and save to snapshot files [snapshot_filename].[single|binary|triple|quadruple];")
        print("                            Without this option, only singles and binaries are detected.")
        print("                            When this option is used, the option '-r' cannot be used to restart data processing.")
        print("  -a(--average-mode)    [S] Lagrangian property average mode; choices: (default sphere).")
        print("                                sphere: average from center to Lagrangian radii")
        print("                                shell (average between two neighboring radii")
        print("  -A(--append)              Append new data to existing data files.")
        print("  -r(--read-data)           Read existing single, binary, and core data to avoid expensive KDTree construction; no argument, disabled by default.")
        print("     --r-escape       [S|F] Distance criterion for escaper; if the value is 'tidal', calculate the tidal radius (only works when external-mode is on); otherwise, it is a constant escape distance criterion. If not given, it is 20 times the half-mass radius.")
        print("     --e-escape       [S|F] Energy criterion for escaper; if the value is 'bound_noext', calculate bound energy without external potential and remove etot > 0; otherwise etot > mass * e-escape (default: 0.0).")
        print("     --m-ext            [S] Read a table of masses of external potential for each time, used for the calculation of tidal radius (default: not used).")
        print("                            The argument is the filename of the table. The file contains two columns: time, mass.")
        print("  -i(--interrupt-mode)  [S] The interruption mode used in petar; choices: no, base, bse, mobse (default: no).")
        print("  -t(--external-mode)   [S] External mode used in petar; choices: galpy, no (default: no).")
        print("  -P(--use_mpfrc)           Include three columns of high-precision parts of particle position x, y, z.")
        print("  -s(--snapshot-format) [S] Input snapshot data format: binary, ascii (default: ascii).")
        print("                             Refer to the '-i' option of petar.")
        print("     --esc-snapshot-format [S] Set escaper snapshot data format for reading: binary, ascii, npy (follows -s).")
        print("                               These files (*.esc_single, *.esc_binary) are generated by the previous petar.data.process.")
        print("                               This option is used when the option '--append' is switched on.")
        print("  -o(--output-format)   [S] Output data format for single, binary, and multiple snapshots: ascii, binary, npy (default: ascii).")
        print("  -e(--calc-energy)         Enable the calculation of potential energy and virial ratio -(2*ekin/epot) of different Lagrangian radii.")
        print("  -c(--calc-multi-rc)       Enable the calculation of individual core radius for each group chosen for Lagrangian properties (e.g., single, binary, and star type);")
        print("                            The centers are also recalculated for individual groups (time-consuming computation).")
        print("  -n(--n-cpu)           [I] Number of CPU threads for parallel processing (default: all threads).")
        print("     --add-star-type    [S] Calculate addtional Lagrangian properties for specific types of stars.")
        print("          This argument contains a list of type names, separated by ',' without empty spaces.")
        print("          For each given type name, an additional group of data is added in the Lagrangian data file [prefix].lagr.")
        print("          There are four styles of type names:")
        print("            (1) a single SSE type name")
        print("                Calculate Lagrangian properties for the specified single stellar type.")
        print("                For example, if 'BH' is provided, the Lagrangian properties of black holes are calculated.")
        print("            (2) a combination of different SSE types connected by '_'")
        print("                Calculate Lagrangian properties for the specified multiple stellar types.")
        print("                For example, if 'BH_NS_WD' is provided, the Lagrangian properties for black holes, neutron stars, and white dwarfs are calculated.")
        print("            (3) a single SSE type name with the prefix 'no'")
        print("                Calculate Lagrangian properties excluding the specified stellar type.")
        print("                For example, if 'noBH' is provided, the Lagrangian properties excluding black holes are calculated.")
        print("            (4) two types (can be any combination of styles 1-3) are given as '[type 1]__in__[type 2]'")
        print("                Calculate Lagrangian properties excluding the radii of type 1 within the sphere or shell defined by the Lagrangian radii of type 2.")
        print("                For example, if 'BH__in__all' is provided, Lagrangian properties of black holes are calculated within the shell or sphere defined by the Lagrangian radii of all stars.")
        print("                Note that the two type names (excluding 'all') should also be added separately in the list.")
        print("                For example, if 'BH__in__MS' is included, 'BH' and 'MS' should both be added together as: BH,MS,BH__in__MS.")
        print("          - All these styles can be combined and calculated simultaneously, e.g., '--add-star-type NS_BH,MS,NS_BH__in__MS,noBH'.")
        print("          - When this option is used, to read the [prefix].lagr file using petar.LagrangianMultiple, the consistent keyword argument 'add_star_type' should be used.")
        print("            For example, if '--add-star-type BH,MS' is used in petar.data.process, petar.LagrangianMultiple should include the keyword argument 'add_star_type=['BH','MS']'.")
        print("            The corresponding class member names are 'BH' and 'MS'.")
        print("          - The SSE star type names are shown below:")
        print("              LMS: deeply or fully convective low mass MS star [0]")
        print("              MS:   Main Sequence star [1]")
        print("              HG:   Hertzsprung Gap [2]")
        print("              GB:   First Giant Branch [3]")
        print("              CHeB: Core Helium Burning [4]")
        print("              FAGB: First Asymptotic Giant Branch [5]")
        print("              SAGB: Second Asymptotic Giant Branch [6]")
        print("              HeMS: Main Sequence Naked Helium star [7]")
        print("              HeHG: Hertzsprung Gap Naked Helium star [8]")
        print("              HeGB: Giant Branch Naked Helium star [9]")
        print("              HeWD: Helium White Dwarf [10]")
        print("              COWD: Carbon/Oxygen White Dwarf [11]")
        print("              ONWD: Oxygen/Neon White Dwarf [12]")
        print("              NS:   Neutron Star [13]")
        print("              BH:   Black Hole [14]")
        print("              SN:   Massless Supernova [15]")
        print("     --add-mass-range   [S] Calculate addtional Lagrangian properties for specific mass ranges of objects.")
        print("          This argument contains a list of mass ranges, separated by ',' without empty spaces.")
        print("          For each given mass range, an additional group of data is added in the Lagrangian data file [prefix].lagr.")
        print("          There are two styles of mass ranges:")
        print("            (1) [minimum mass]_[maximum mass]")
        print("                Calculate Lagrangian properties for the objects in a mass range.")
        print("                For example, if '0.08_1' is given, Lagrangian properties are calculated by selecting objects with masses from 0.08 to 1.0.")
        print("                Be aware that the minimum mass must be > 0.")
        print("            (2) [mass range 1]__in__[mass range 2]")
        print("                Calculate Lagrangian properties of the mass range 1 within the sphere or shell defined by the Lagrangian radii of mass range 2.")
        print("                The [mass range 1] and [mass range 2] have the same syntax of the style (1).")
        print("                For example, if '1_150__in__0.08_1' is given, Lagrangian properties with masses from 1 to 150 are calculated within the sphere or shell defined by the Lagrangian radii with masses from 0.08 to 1.0.")
        print("                To use this style,  both [mass range 1] and [mass range 2] should be added simultaneously.")
        print("          - All these styles can be combined, similar to '--add-star-type'.")
        print("          - When this option is used, to read the [prefix].lagr file using petar.LagrangianMultiple, the consistent keyword argument 'add_mass_range' should be used.")
        print("            For example, if '--add-mass-range 0.08_1,1_150,0.08_1__in__1_150' is used in petar.data.process, petar.LagrangianMultiple should include the keyword argument 'add_mass_range=['0.08_1','1_150','0.08_1__in__1_150'.")
        print("            The corresponding class member names are 'mass_0.08_1', 'mass_1_150', and 'mass_0.08_1__in__1_150'.")
        print("Important notes:")
        print("  1) Ensure correct options are set for '-i', '-t', and '-G' to read snapshots accurately and calculate Kepler orbital parameters correctly.")
        print("     When using the compiled SSE/BSE stellar evolution package, use '-i bse'. Note that even if SSE/BSE is compiled but switched off during petar usage, '-i bse' is still required.")
        print("     Similarly, when the Galpy external potential support is compiled, use '-i galpy' regardless of whether external potential is set in petar options during simulation.")
        print("     Make sure to set the correct value for '-G' based on the units used during petar usage.")
        print("  2) If data is written in BINARY format during petar simulation, use '-s binary'.")
        print("  3) '--add-star-type' functionality is only available when SSE/BSE is used.")
    try:
        shortargs = 'p:m:G:b:MBAea:rt:i:Ps:o:cn:h'
        longargs = ['mass-fraction=','multiple','gravitational-constant=','r-max-binary=','full-binary','average-mode=', 'filename-prefix=','read-data','calc-energy','r-escape=','append','e-escape=','external-mode=','interrupt-mode=','use-mpfrc','snapshot-format=','output-format=','m-ext=','add-star-type=','add-mass-range=','calc-multi-rc','n-cpu=','help']
        opts,remainder= getopt.getopt( sys.argv[1:], shortargs, longargs)

        kwargs=dict()
        for opt,arg in opts:
            if opt in ('-h','--help'):
                usage()
                sys.exit(1)
            elif opt in ('-p','--filename-prefix'):
                filename_prefix = arg
            elif opt in ('-m','--mass-fraction'):
                kwargs['mass_fraction'] = np.array([float(x) for x in arg.split(',')])
            elif opt in ('-M','--multiple'):
                kwargs['find_multiple'] = True
            elif opt in ('-G','--gravitational-constant'):
                kwargs['G'] = float(arg)
            elif opt in ('-b','--r-max-binary'):
                kwargs['r_max_binary'] = float(arg)
            elif opt in ('-B','--full-binary'):
                kwargs['simple_mode'] = False
            elif opt in ('-a','--average-mode'):
                kwargs['average_mode'] = arg
            elif opt in ('-A','--append'):
                write_option='a'
            elif opt in ('-e','--calc-energy'):
                kwargs['calc_energy']=True
            elif opt in ('-n','--n-cpu'):
                n_cpu = int(arg)
            elif opt in ('-i','--interrupt-mode'):
                kwargs['interrupt_mode'] = arg
            elif opt in ('-t','--external-mode'):
                kwargs['external_mode'] = arg
            elif opt in ('-P','--use_mpfrc'):
                kwargs['use_mpfrc'] = True
            elif opt in ('-s','--snapshot-format'):
                kwargs['snapshot_format'] = arg
                snapshot_format = arg
                if (not 'esc_snapshot_format' in kwargs.keys()):
                    esc_snapshot_format = arg
            elif opt in ('--esc-snapshot-format'):
                kwargs['esc_snapshot_format'] = arg
                esc_snapshot_format = arg
            elif opt in ('-o','--output-format'):
                kwargs['output_format'] = arg
                output_format = arg
            elif opt in ('-r','--read-data'):
                read_flag = True
            elif opt in ('-c','--calc-multi-rc'):
                kwargs['calc_multi_rc']=True
            elif opt in ('--r-escape'):
                if (arg=='tidal'): 
                    kwargs['r_escape'] = arg
                    ftid_file_flag = True
                else: kwargs['r_escape'] = float(arg)
            elif opt in ('--e-escape'):
                kwargs['e_escape'] = arg
            elif opt in ('--m-ext'):
                kwargs['read_m_ext'] = arg
            elif opt in ('--add-star-type'):
                kwargs['add_star_type'] = [x for x in arg.split(',')]
            elif opt in ('--add-mass-range'):
                kwargs['add_mass_range'] = [x for x in arg.split(',')]
            else:
                assert False, "unhandeld option"

    except getopt.GetoptError:
        print('getopt error!')
        usage()
        sys.exit(1)

    filename = remainder[0]

    if (not 'G' in kwargs.keys()):
        if ('interrupt_mode' in kwargs.keys()):
            if ('bse' in kwargs['interrupt_mode']): kwargs['G'] = 0.00449830997959438 # pc^3/(Msun*Myr^2)

    kwargs['filename_prefix'] = filename_prefix

    for key, item in kwargs.items(): print(key,':',item)

    fl = open(filename,'r')
    file_list = fl.read()
    path_list = file_list.splitlines()
    fl.close()

    result=dict()
    time_profile=dict()
    if (n_cpu==1):
        result,time_profile = petar.dataProcessList(path_list, read_flag, **kwargs)
    else:
        result,time_profile = petar.parallelDataProcessList(path_list, n_cpu, read_flag, **kwargs)

    fout_list=['lagr','core','bse_status']
    if (ftid_file_flag): fout_list.append('tidal')

    for key in fout_list:
        if key in result.keys():
            key_filename  = filename_prefix + '.' + key
            with open(key_filename, write_option) as f:
                result[key].savetxt(f)
                print (key,"data is saved in file:",key_filename)

    for key in ['esc_single','esc_binary']:
        if key in result.keys():
            key_filename  = filename_prefix + '.' + key
            result_mix = result[key]
            if (write_option=='a'):
                data_read = None
                if (key == 'esc_single'):
                    data_read=petar.SingleEscaper(**kwargs)
                else:
                    data_read=petar.BinaryEscaper(**kwargs)
                if os.path.getsize(key_filename)>0:
                    if (esc_snapshot_format=='ascii'):
                        data_read.loadtxt(key_filename)
                    elif (esc_snapshot_format=='binary'):
                        data_read.fromfile(key_filename)
                    elif (esc_snapshot_format=='npy'):
                        data_read.load(key_filename)
                    else:
                        raise ValueError('Snapshot format %s unknown, should be ascii, binary or npy.' % snapshot_format)                                            
                    result_mix = petar.join(data_read,result[key])
                    result_mix.removeDuplicate()
                
            if (output_format=='ascii'):
                with open(key_filename, 'w') as f:
                    result_mix.savetxt(f)
            elif (output_format=='binary'):
                with open(key_filename, 'wb') as f:
                    result_mix.tofile(f)
            elif (output_format=='npy'):
                with open(key_filename, 'wb') as f:
                    result_mix.save(f)
            else:
                raise ValueError('Output format %s is unknown, should be ascii, binary or npy.' % output_format)
            print ("%s data is saved in file: %s" % (key,key_filename))

    print ('CPU time profile:')
    for key, item in time_profile.items():
        print (key,item,)
