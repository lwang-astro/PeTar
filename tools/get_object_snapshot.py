#!/usr/bin/env python3

import numpy as np
import sys
import os
import petar
import getopt

if __name__ == '__main__':

    filename_prefix='object'
    snap_type='origin'
    mode='type'
    snapshot_format='ascii'
    output_format='ascii'
    interrupt_mode='bse'
    external_mode='none'
    simple_binary=True
    write_option='w'
    core_file='data.core'
    cm_mode='core'

    def usage():
        print("A tool for gathering specified objects from a list of snapshots into one file with a time series.")
        print("  Users can specify IDs, stellar types, mass ranges, and a custom-defined Python script to select objects.")
        print("Usage: petar.get.object.snap [options] [mode_argument] [mode_argument_b] [snapshot path list filename]")
        print("  snapshot path list filename:   A list of Petar snapshot data paths, with each line representing one snapshot.")
        print("                                 This file can be generated by petar.data.gather.")
        print("  mode_argument:   Selection criterion based on the option '-m', must be provided.")
        print("  mode_argument_b: Selection criterion for the secondary component when reading snapshots that include binaries.")
        print("Output file syntax:")
        print("  1) The output file has the naming style of [prefix].[object_typename].[origin|single|binary].")
        print("        [prefix] is defined in the option -p;")
        print("        [object_typename] is defined by selection criterion, referring to the option '-m';")
        print("        [origin|single|binary] represent the original snapshots from PeTar, generated single, or binary ones from petar.data.process, respectively.")
        print("  1) The new file inherits the original columns of snapshots with an additional column of time obtained from the headers of snapshots.")
        print("     If the options '-m bid' or '-m bidfile' are used, one more column of binary ID is added in front of the 'time' column.")
        print("  3) To read the file generated by this tool using Python data analysis classes petar.Particle or petar.Binary, users need to manually add the additional members as follows:")
        print("     If the options '-m bid' or '-m bidfile' are used, two instances of addNewMember are needed:")
        print("        addNewMember('bid', np.array([]).astype(int))")
        print("        addNewMember('time', np.array([]).astype(float))")
        print("     Otherwise:")
        print("        addNewMember('time', np.array([]).astype(float)) first.")
        print("Options (default arguments shown in parentheses at the end):")
        print("  -h(--help)                 Display help information")        
        print("  -p(--filename-prefix) [S]  Prefix of the output file name (default: %s)" % filename_prefix)
        print("  -f(--snapshot-type)   [S]  The type of snapshot to read: origin, single, binary, all (default: %s)" % snap_type)
        print("       The following definitions apply to the types:")
        print("         - origin: Read original snapshots from Petar")
        print("         - single: Read snapshots containing single stars (generated by petar.data.process)")
        print("         - binary: Read snapshots containing binaries (generated by petar.data.process)")
        print("         - all: Read all snapshots, including origin, single, and binary; used only for '-m custom'")
        print("       For any snapshot type, only the original snapshot path is needed in the snapshot path list file.")
        print("       The original snapshots from Petar are always required to obtain the time from the header.")
        print("       When including binaries, [mode_argument_b] should be provided, except when '-m custom' is used.")
        print("  -m(--mode)            [S]  The object selection criterion modes (default: %s)" % mode)
        print("       The following show the choices of modes and the corresponding setting of mode_argument(_b):")
        print("       type:  Select stars based on SSE stellar types")
        print("          There are three styles of mode_argument(_b):")
        print("            (1) single SSE type name, such as BH, MS")
        print("            (2) multiple SSE types combined with '_'. For example, 'BH_MS' gathers types of both BH and MS.")
        print("            (3) excluding SSE type with the prefix 'no'. For example, 'noBH' indicates to find all objects except BHs.")
        print("          Here are options of SSE types:")
        print("               LMS:  Deeply or fully convective low mass MS star [0]")
        print("               MS:   Main Sequence star [1]")
        print("               HG:   Hertzsprung Gap [2]")
        print("               GB:   First Giant Branch [3]")
        print("               CHeB: Core Helium Burning [4]")
        print("               FAGB: First Asymptotic Giant Branch [5]")
        print("               SAGB: Second Asymptotic Giant Branch [6]")
        print("               HeMS: Main Sequence Naked Helium star [7]")
        print("               HeHG: Hertzsprung Gap Naked Helium star [8]")
        print("               HeGB: Giant Branch Naked Helium star [9]")
        print("               HeWD: Helium White Dwarf [10]")
        print("               COWD: Carbon/Oxygen White Dwarf [11]")
        print("               ONWD: Oxygen/Neon White Dwarf [12]")
        print("               NS:   Neutron Star [13]")
        print("               BH:   Black Hole [14]")
        print("               SN:   Massless Supernova [15]")
        print("       id:     Select objects based on particle ID, where more than one ID can be connected by '_'.")
        print("               For example, '1_2_3' indicates that particles with ID of 1, 2, or 3 will be recorded.")
        print("       idfile: Read a file containing a list of object IDs to select objects, with one ID per line.")
        print("       bid:    Select binaries based on binary ID.")
        print("               Binary IDs can be generated by the petar.Binary member function 'generateBinaryID'.")
        print("       bidfile: Read a file containing a list of binary IDs to select objects, with one ID per line.")
        print("       mass:   Select objects based on a mass range. The range is connected by '_'.")
        print("               For example, '0.5_1' indicates mass between 0.5 and 1.0.")
        print("       custom: Select particles based on a user-defined selection function in Python.")
        print("               The filename of a Python script is provided as mode_argument.")
        print("               1) When the option '-f' is origin, single, or binary, the script syntax:")
        print("               def petar_data_select_function(header, data):")
        print("                   # header: origin snapshot header")
        print("                   # data:   origin, single, or binary snapshot (no correction of c.m. stored in header)")
        print("                   # Return filtered data; the format can be different from the original one.")
        print("                   # For example, return only the stellar evolution data with mass > 10:")
        print("                   return data.star[data.mass > 10]")
        print("               2) When '-f all' is used:")
        print("               def petar_data_select_function(header, core, origin, single, binary):")
        print("                   # header: origin snapshot header")
        print("                   # core: core data at the time of the snapshot")
        print("                   # origin, single, and binary: all three types of snapshots without position and velocity correction")
        print("                   # Return selected data")
        print("  -i(--interrupt-mode)  [S]  The interruption mode used in Petar, choices: bse, mobse [%s]" % interrupt_mode)
        print("  -t(--external-mode)   [S]  External mode used in Petar, choices: galpy, none [%s]" % external_mode)
        print("       Notice that when the external mode is not none and the mode is not custom,")
        print("       the position and velocity offset from the header are added for single and binary snapshots.")
        print("  -s(--snapshot-format) [S]  Reading snapshot format: ascii, binary, npy [%s]" % snapshot_format)
        print("       ascii:  All snapshots are in ascii format.")
        print("       binary: All snapshots are in binary format.")
        print("       npy: Snapshots from Petar (data.*) are in binary format;")
        print("            Snapshots from petar.data.process (data.*.[single/binary]) are in npy format.")
        print("  -o(--output-format)   [S]  Output data format: binary, ascii [%s]" % output_format)
        print("  -B(--full-binary)          This indicates that the snapshot contains full binary information (when petar.data.process -B is used to generate the binary snapshot).")
        print("  -a(--append)               Appending data to existing data files.")
        print("  -c(--cm-mode)         [S]  Correct positions and velocity of particles: header, core, none [%s]" % cm_mode)
        print("       Used when '--external-mode' is not none and '-m' is not custom, options definitions:")
        print("         external: Transfer to external frame (e.g. galactic center in MWPotential of galpy).")
        print("            Origin snapshot: + header offset.")
        print("            Single(binary) snapshot: + core offset.")
        print("         core: Transfer to particle system center (core center).")
        print("            Origin snapshot: + header offset - core offset.")
        print("            Single(binary) snapshot: no correction.")
        print("         none: No correction.")
        print("            Origin snapshot: Center of soft potential.")
        print("            Single(binary) snapshot: Core center.")
        print("  -C(--core-file)       [S]  Core data filename, for correction of position and velocity of single and binary snapshots [%s]" % core_file)
    try:
        shortargs = 'p:f:Bt:i:s:o:c:C:m:ah'
        longargs = ['append','snapshot-type','full-binary','filename-prefix=','mode=','external-mode=','interrupt-mode=','snapshot-format=','output-format=','cm-mode=','core-file=','help']
        opts,remainder= getopt.getopt( sys.argv[1:], shortargs, longargs)

        kwargs=dict()
        for opt,arg in opts:
            if opt in ('-h','--help'):
                usage()
                sys.exit(1)
            elif opt in ('-p','--filename-prefix'):
                filename_prefix = arg
            elif opt in ('-f','--snapshot-type'):
                snap_type = arg
                if (arg not in ['all','single','binary','origin']):
                    raise ValueError("Snapshot type is incorrect, given", arg, ", should be all, single, binary or origin")
            elif opt in ('-m', '--mode'):
                mode = arg
            elif opt in ('-B','--full-binary'):
                simple_binary = False
            elif opt in ('-a','--append'):
                write_option='a'
            elif opt in ('-i','--interrupt-mode'):
                interrupt_mode = arg
            elif opt in ('-t','--external-mode'):
                external_mode = arg
            elif opt in ('-s','--snapshot-format'):
                snapshot_format = arg
            elif opt in ('-o','--output-format'):
                output_format = arg
            elif opt in ('-c','--cm-mode'):
                cm_mode = arg
            elif opt in ('-C','--core-file'):
                core_file = arg
            else:
                assert False, "unhandeld option"

    except getopt.GetoptError:
        print('getopt error!')
        usage()
        sys.exit(1)

    if (mode=='bid') | (mode=='bidfile'):
        if (snap_type!='binary'):
            raise ValueError("Mode is %s but snapshot file type (-f) is not binary (given: %s)" % (mode,snap_type))

    if (mode != 'custom') & (snap_type == 'all'):
        raise ValueError("Snapshot type is all but Mode is not custom")

    sse_type=''
    sse_type2=''
    mass_range=[]
    mass_range2=[]
    filename_out=''
    idlist=''
    custom_script=''
    if (mode=='type'): 
        sse_type = remainder[0]
        filename = remainder[1]
        if (snap_type=='binary'):
            sse_type2 = remainder[1]
            filename = remainder[2]
        filename_out = filename_prefix+'.'+sse_type+'.'+snap_type
        if (snap_type=='binary'):     
            filename_out = filename_prefix+'.'+sse_type+'.'+sse_type2+'.'+snap_type
    elif (mode=='id') | (mode=='bid'):
        idarg = remainder[0]
        idlist=[]
        for subtype in idarg.split('_'):
            idlist.append(int(subtype))
        idlist=np.array(idlist)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+idarg
    elif (mode=='idfile') | (mode=='bidfile'):
        idfile = open(remainder[0],'r')
        idlines=idfile.read().splitlines()
        idlist=[]
        for line in idlines:
            idlist.extend([int(x) for x in line.split()])
        idlist=np.array(idlist)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+remainder[0]
    elif (mode=='mass') :
        mass_range = [float(x) for x in remainder[0].split('_')]
        if (len(mass_range)!=2):
            raise ValueError('Mass range should has a format of "min_max", ',remainder[0],' is given.')
        if (snap_type=='binary'):
            mass_range2 = [float(x) for x in remainder[1].split('_')]
            if (len(mass_range2)!=2):
                raise ValueError('Mass range should has a format of "min_max", ',remainder[1],' is given.')
        filename = remainder[1]
        filename_out = filename_prefix+'.m'+remainder[0]+'.'+snap_type
        if (snap_type=='binary'):     
            filename = remainder[2]
            filename_out = filename_prefix+'.m'+remainder[0]+'.m'+remainder[1]+'.'+snap_type
    elif (mode=='custom'):
        custom_script = remainder[0]
        selfun = __import__(custom_script)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+remainder[0]
    else:
        raise ValueError("Mode is not recognized, given ", mode, ", should be type, id, idfile, mass, bid, bidfile or custom.")

    if (output_format!='ascii'):
        write_option = write_option + 'b'
    print('Output file: ',filename_out)

    snap_kwargs=dict()
    snap_kwargs['interrupt_mode'] = interrupt_mode
    snap_kwargs['external_mode'] = external_mode
    snap_kwargs['snapshot_format'] = snapshot_format
    snap_kwargs['simple_mode'] = simple_binary

    for key, item in snap_kwargs.items(): print(key,':',item)
    for key, item in kwargs.items(): print(key,':',item)

    fl = open(filename,'r')
    file_list = fl.read()
    path_list = file_list.splitlines()
    fl.close()

    core = petar.Core()
    read_core = False
    if (cm_mode == 'core') | ((snap_type != 'origin') & (cm_mode == 'external')):
        core.loadtxt(core_file)
        read_core = True

    def select_type(_data, _type):
        sel = np.zeros(_data.size).astype(bool)
        for subtype in _type.split('_'):
            if (subtype[:2]=='no'):
                type_index = petar.BSE_STAR_TYPE_INDEX[subtype[2:]]
                sel = sel | (_data.star.type!=type_index)
            else:
                type_index = petar.BSE_STAR_TYPE_INDEX[subtype]
                sel = sel | (_data.star.type==type_index)
        return sel


    with open(filename_out, write_option) as f:
        for path in path_list:
            print('process ',path)
            header = petar.PeTarDataHeader(path, **snap_kwargs)
            time = header.time
            sel = np.array([])
            read_flag=False
            core_t = None
            if (read_core):
                core_t = core[(core.time==time)][0]

            if (snap_type=='binary'):
                p1_temp = petar.Particle(**snap_kwargs)
                p2_temp = petar.Particle(**snap_kwargs)
                data_temp=petar.Binary(p1_temp, p2_temp, **snap_kwargs)
                if os.path.getsize(path+'.binary')>0:
                    if (snapshot_format=='ascii'): 
                        data_temp.loadtxt(path+'.binary')
                    elif (snapshot_format=='binary'):
                        data_temp.fromfile(path+'.binary')
                    elif (snapshot_format=='npy'):
                        data_temp.load(path+'.binary.npy') 
                    else:
                        raise ValueError('Snapshot format %s unknown, should be ascii, binary or npy.' % snapshot_format)                        
                    if (mode=='custom'):
                        data_sel = selfun.petar_data_select_function(core_t, data_temp)
                    elif (external_mode!='none'): 
                        if (cm_mode=='external'):
                            data_temp.pos += core_t.pos
                            data_temp.vel += core_t.vel
                            data_temp.p1.pos += core_t.pos
                            data_temp.p2.pos += core_t.pos
                            data_temp.p1.vel += core_t.vel
                            data_temp.p2.vel += core_t.vel
                    if (mode=='type'):
                        sel1 = select_type(data_temp.p1, sse_type)
                        sel2 = select_type(data_temp.p2, sse_type2)
                        sel = sel1 & sel2
                     
                        sel1 = select_type(data_temp.p1, sse_type2)
                        sel2 = select_type(data_temp.p2, sse_type)
                        sel = sel | (sel1 & sel2)
                    elif (mode=='id') | (mode=='idfile'):
                        sel1 = np.in1d(data_temp.p1.id, idlist)
                        sel2 = np.in1d(data_temp.p2.id, idlist)
                        sel = sel1 | sel2
                    elif (mode=='bid') | (mode=='bidfile'):
                        data_temp.generateBinaryID()
                        sel = np.in1d(data_temp.bid, idlist)
                    elif (mode=='mass'):
                        sel1 = (data_temp.p1.mass >= mass_range[0]) & (data_temp.p1.mass < mass_range[1])
                        sel2 = (data_temp.p2.mass >= mass_range2[0]) & (data_temp.p2.mass < mass_range2[1])
                        sel = sel1 & sel2
 
                        sel1 = (data_temp.p2.mass >= mass_range[0]) & (data_temp.p2.mass < mass_range[1])
                        sel2 = (data_temp.p1.mass >= mass_range2[0]) & (data_temp.p1.mass < mass_range2[1])
                        sel = sel | (sel1 & sel2)
                    read_flag=True
                
            elif (snap_type=='single') | (snap_type=='origin'):
                data_temp=petar.Particle(**snap_kwargs)
                read_flag=False
                if (snapshot_format=='ascii'): 
                    if (snap_type=='origin'):
                        data_temp.loadtxt(path, skiprows=1)
                        read_flag=True
                    else:
                        if os.path.getsize(path+'.single')>0:
                            data_temp.loadtxt(path+'.single')
                            read_flag=True                            
                elif (snapshot_format=='binary'): 
                    if (snap_type=='origin'):
                        if (external_mode!='none'): 
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                        else:
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET)
                        read_flag=True
                    else:
                        if os.path.getsize(path+'.single')>0:
                            data_temp.fromfile(path+'.single')
                            read_flag=True
                elif (snapshot_format=='npy'): 
                    if (snap_type=='origin'):
                        if (external_mode!='none'): 
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                        else:
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET)
                        read_flag=True
                    else:
                        if os.path.getsize(path+'.single.npy')>0:
                            data_temp.load(path+'.single.npy')
                            read_flag=True
                else:
                    raise ValueError('Snapshot format %s unknown, should be ascii, binary or npy.' % snapshot_format)
                if (read_flag):
                    if (mode=='custom'):
                        if (snap_type=='origin'):
                            data_sel = selfun.petar_data_select_function(header, data_temp)
                        else:
                            data_sel = selfun.petar_data_select_function(core_t, data_temp)
                    elif (external_mode!='none'): 
                        if (cm_mode=='external'):
                            if (snap_type=='origin'):
                                data_temp.pos += header.pos_offset
                                data_temp.vel += header.vel_offset
                            else:
                                data_temp.pos += core_t.pos
                                data_temp.vel += core_t.vel
                        elif (cm_mode=='core'):
                            if (snap_type=='origin'):
                                data_temp.pos += header.pos_offset - core_t.pos
                                data_temp.vel += header.vel_offset - core_t.vel

                    if (mode=='type'):
                        sel = select_type(data_temp, sse_type)
                    elif (mode=='id') | (mode=='idfile'):
                        sel = np.in1d(data_temp.id, idlist)
                    elif (mode=='mass'):
                        sel = (data_temp.mass >= mass_range[0]) & (data_temp.mass < mass_range[1])

            elif (snap_type=='all') & (mode == 'custom'):
                p1_temp = petar.Particle(**snap_kwargs)
                p2_temp = petar.Particle(**snap_kwargs)
                binary=petar.Binary(p1_temp, p2_temp, **snap_kwargs)
                origin=petar.Particle(**snap_kwargs)
                single=petar.Particle(**snap_kwargs)
                if (snapshot_format=='ascii'): 
                    origin.loadtxt(path, skiprows=1)
                    if os.path.getsize(path+'.single')>0:
                        single.loadtxt(path+'.single')
                    if os.path.getsize(path+'.binary')>0:
                        binary.loadtxt(path+'.binary')
                elif (snapshot_format=='binary'): 
                    if (external_mode!='none'): 
                        origin.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                    else:
                        origin.fromfile(path, offset=petar.HEADER_OFFSET)
                    if os.path.getsize(path+'.single')>0:
                        single.fromfile(path+'.single')
                    if os.path.getsize(path+'.binary')>0:
                        binary.fromfile(path+'.binary')
                elif (snapshot_format=='npy'):
                    if (external_mode!='none'): 
                        origin.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                    else:
                        origin.fromfile(path, offset=petar.HEADER_OFFSET)
                    if os.path.getsize(path+'.single.npy')>0:
                        single.load(path+'.single.npy')
                    if os.path.getsize(path+'.binary')>0:
                        binary.load(path+'.binary.npy')
                else:
                    raise ValueError('Snapshot format %s is unknown, should be ascii, binary or npy.' % snapshot_format)                    
                        
                data_sel = selfun.petar_data_select_function(header, core_t, origin, single, binary)
                read_flag = True

            if(read_flag):
                if (mode != 'custom'):
                    data_sel = data_temp[sel]
                data_sel.addNewMember('time',(np.ones(data_sel.size)*time).astype(np.float64))
                if (output_format=='ascii'):
                    data_sel.savetxt(f)
                elif (output_format=='binary'):
                    data_sel.tofile(f)
                else:
                    raise ValueError('Output format %s is unknown, should be ascii, binary or npy.' % output_format)
                f.flush()
    
