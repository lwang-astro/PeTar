#!/usr/bin/env python3

import numpy as np
import sys
import os
import petar
import getopt

if __name__ == '__main__':

    filename_prefix='object'
    snap_type='origin'
    mode='type'
    snapshot_format='ascii'
    output_format='ascii'
    interrupt_mode='bse'
    external_mode='none'
    write_option='w'
    core_file='data.core'
    cm_mode='core'

    def usage():
        print("A tool to gether objects from a list of snapshots into one file.")
        print("Function:")
        print(" - The tool scan a list of snapshots, gether user defined types of data")
        print("   and save the data into one file.")
        print(" - The new file inherits the original members (columns) of snapshots")
        print(" - An additional member (column) 'time' obtained from petar original snapshot header")
        print(" - If -m bid or -m bidfile are used, one more member 'bid' is added (in front of 'time').")
        print(" - To read the file generated by this tool, users need to manually add the additional members(columns) by using:")
        print("   For -m bid or -m bidfile, two times of addNewMember are needed:")
        print("        addNewMember('bid', np.array([]).astype(int))")
        print("        addNewMember('time', np.array([]).astype(float))")
        print("   Otherwise: ")
        print("        addNewMember('time', np.array([]).astype(float)) first.")
        print("   Output file has the name style of [prefix].[object_typename].[origin|single|binary]")
        print("        [prefix] is defined in the option -p;")
        print("        [object_typename] is defined by SSE star type shown below;")
        print("        [origin|single|binary] represent the original snapshots from PeTar, generated single or binary ones from petar.data.process, respectively.")
        print("Usage: petar.get.object.snap [options] mode_arguments [mode_arguments_2] data_filename_list")
        print("data_filename_list: a list of snapshot data path with the original filenames (no suffixes of '.single|.binary').")
        print("    Each line indicates one snapshot.")
        print("    Can be generated by petar.data.gether ([filename prefix].snap.lst)")
        print("mode_arguments(mode_arguments_2): selection criterions based on option '-m':")
        print("    When reading snapshots include binaries, mode_arguments_2 are needed for selection secondary components.")
        print("    Argument types:")
        print("    ---------------")
        print("    type(typeb): (-m type) select stars based on SSE based stellar type (e.g. BH, MS)")
        print("      - Multiple types can be combined by '_': [type1]_[type2]...")
        print("        For exmaple, 'BH_MS' gather types of both BH and MS.")
        print("      - If 'no' is added in front of type name, it indicate to select all other types.")
        print("        For exmaple, 'noBH' indicates to find all objects except BHs.")
        print("      - Here are options of SSE types (number in [] is the original type index):")
        print("            LMS:  deeply or fully convective low mass MS star [0]")
        print("            MS:   Main Sequence star [1]")
        print("            HG:   Hertzsprung Gap [2]")
        print("            GB:   First Giant Branch [3]")
        print("            CHeB: Core Helium Burning [4]")
        print("            FAGB: First Asymptotic Giant Branch [5]")
        print("            SAGB: Second Asymptotic Giant Branch [6]")
        print("            HeMS: Main Sequence Naked Helium star [7]")
        print("            HeHG: Hertzsprung Gap Naked Helium star [8]")
        print("            HeGB: Giant Branch Naked Helium star [9]")
        print("            HeWD: Helium White Dwarf [10]")
        print("            COWD: Carbon/Oxygen White Dwarf [11]")
        print("            ONWD: Oxygen/Neon White Dwarf [12]")
        print("            NS:   Neutron Star [13]")
        print("            BH:   Black Hole [14]")
        print("            SN:   Massless Supernova [15]")
        print("    id: (-m id) select data based on particle ID, more than one ID can be connected by '_'.")
        print("        For example, '1_2_3' indicates that particles with ID of 1,2 or 3 will be recorded.")
        print("    id_filename: (-m idfile) the name of a file that contain a list of id. This is used when the option '-m idfile' is given.")
        print("    bid: (-m bid) select binaries based on binary ID")
        print("        Binary ID can be generated by petar.Binary member function 'generateBinaryID'")
        print("    bid_filename: (-m bidfile) the name of a file containing a list of binary ID")
        print("mass_range(mass_rangeb): (-m mass) select particles based on a mass range. The range is connected by '_'.")
        print("        For example, '0.5_1' indicates mass between 0.5 and 1.0.")
        print("    custom: (-m custom) select particles based on user defined selection function.")
        print("        The filename of a python script is provided.")
        print("        The script includes a defination of selecting function with the syntax:")
        print("        #------------------------------------------------")
        print("        #When option of '-f' is origin, single or binary:")
        print("        def petar_data_select_function(header, data):")
        print("            # The arguments:")
        print("            # header: origin snapshot header")
        print("            # data: origin, single or binary snapshot (no correction of c.m. stored in header)")
        print("            # Return filtered data, the format can be different from the original one.")
        print("            # For example, return only the stellar evolution data with mass>10:")
        print("            return data.star[data.mass>10] ")
        print("        # When '-f all' is used:")
        print("        def petar_data_select_function(header, core, origin, single, binary):")
        print("            # header: origin snapshot header")
        print("            # core: core data at the time of origin snapshot")
        print("            # origin, single and binary: all three types of snapshots without position and velocity correction")
        print("            # return selected data")
        print("Options (default values are shown in []):")
        print("  -h(--help): help")        
        print("  -p(--filename-prefix): prefix of output file name [%s]" % filename_prefix)
        print("  -f(--snapshot-type): the reading snapshot type: origin, single, binary, all [%s] " % snap_type)
        print("      origin: reading original snapshots from petar")
        print("      single: reading snapshots contain single stars (generated by petar.data.process)")
        print("      binary: reading snapshots contain binaries (generated by petar.data.process)")
        print("      all: all snapshots, origin, single and binary, are read, only used for '-m custom'")
        print("    - Notice that for 'single' and 'binary', data_filename_list don't need the suffixes '.single' or '.binary'")
        print("      the original snapshots from petar are also read to obtain time from the header")
        print("  -m(--mode): the detection modes, options are shown as following: [%s]" % mode)
        print("       type: select objects based on BSE-based stellar types;")
        print("       id: select objects based on id; ")
        print("       idfile: select objects by reading a file of id list;")
        print("       mass: select objects based on mass range")
        print("       custom: user defined python script to select data")
        print("     - Additional options when '-f binary' is used: ")
        print("       bid: select binaries based on binary id (CantorPairing); ")
        print("       bidfile: select binaries by reading a file of binary id list")
        print("  -i(--interrupt-mode): the interruption mode used in petar, choices: bse, mobse [%s]" % interrupt_mode)
        print("  -t(--external-mode): external mode used in petar, choices: galpy, none [%s]" % external_mode)
        print("     - when external mode is not none, and the mode is not custom, ")
        print("     - the position and velocity offset from header are added for single and binary snapshots")
        print("  -s(--snapshot-format): reading snapshot format: ascii, binary, npy [%s]" % snapshot_format)
        print("       ascii:  all snapshots are in ascii format")
        print("       binary: all snapshots are in binary format")
        print("       npy: snapshots from petar (data.*) are in binary format;")
        print("               snapshots from petar.data.process (data.*.[single/binary]) are in npy format")
        print("  -o(--output-format): output data format: binary, ascii [%s]" % output_format)
        print("  -B(--full-binary): this indicates that the snapshot contains full binary information (when petar.data.process -B is used to generated the binary snapshot)")
        print("  -a(--append): appending data to existing data files")
        print("  -c(--cm-mode): correct positions and velocity of particles: header, core, none [%s]" % cm_mode)
        print("     - Used when '--external-mode' is not none and '-m' is not custom, options definitions:")
        print("       external: transfer to external frame (e.g. galactic center in MWPotential of galpy")
        print("          origin snapshot: + header offset")
        print("          single(binary) snapshot: + core offset")
        print("       core: transfer to particle system center (core center)")
        print("          origin snapshot: + header offset - core offset")
        print("          single(binary) snapshot: no correction")
        print("       none: no correction")
        print("          origin snapshot: center of soft potential")
        print("          single(binary) snapshot: core center")
        print("  --core-file: core data filename, for correction of position and velocity of single and binary snapshots [%s]" % core_file)
    try:
        shortargs = 'p:f:Bt:i:s:o:c:m:ah'
        longargs = ['append','snapshot-type','full-binary','filename-prefix=','mode=','external-mode=','interrupt-mode=','snapshot-format=','output-format=','cm-mode=','core-file=','help']
        opts,remainder= getopt.getopt( sys.argv[1:], shortargs, longargs)

        kwargs=dict()
        for opt,arg in opts:
            if opt in ('-h','--help'):
                usage()
                sys.exit(1)
            elif opt in ('-p','--filename-prefix'):
                filename_prefix = arg
            elif opt in ('-f','--snapshot-type'):
                snap_type = arg
                if (arg not in ['all','single','binary','origin']):
                    raise ValueError("Snapshot type is incorrect, given", arg, ", should be all, single, binary or origin")
            elif opt in ('-m', '--mode'):
                mode = arg
            elif opt in ('-B','--full-binary'):
                kwargs['simple_binary'] = False
            elif opt in ('-a','--append'):
                write_option='a'
            elif opt in ('-i','--interrupt-mode'):
                interrupt_mode = arg
            elif opt in ('-t','--external-mode'):
                external_mode = arg
            elif opt in ('-s','--snapshot-format'):
                snapshot_format = arg
            elif opt in ('-o','--output-format'):
                output_format = arg
            elif opt in ('-c','--cm-mode'):
                cm_mode = arg
            elif opt in ('--core-file'):
                core_file = arg
            else:
                assert False, "unhandeld option"

    except getopt.GetoptError:
        print('getopt error!')
        usage()
        sys.exit(1)

    if (mode=='bid') | (mode=='bidfile'):
        if (snap_type!='binary'):
            raise ValueError("Mode is %s but snapshot file type (-f) is not binary (given: %s)" % (mode,snap_type))

    if (mode != 'custom') & (snap_type == 'all'):
        raise ValueError("Snapshot type is all but Mode is not custom")

    sse_type=''
    sse_type2=''
    mass_range=[]
    mass_range2=[]
    filename_out=''
    idlist=''
    custom_script=''
    if (mode=='type'): 
        sse_type = remainder[0]
        filename = remainder[1]
        if (snap_type=='binary'):
            sse_type2 = remainder[1]
            filename = remainder[2]
        filename_out = filename_prefix+'.'+sse_type+'.'+snap_type
        if (snap_type=='binary'):     
            filename_out = filename_prefix+'.'+sse_type+'.'+sse_type2+'.'+snap_type
    elif (mode=='id') | (mode=='bid'):
        idarg = remainder[0]
        idlist=[]
        for subtype in idarg.split('_'):
            idlist.append(int(subtype))
        idlist=np.array(idlist)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+idarg
    elif (mode=='idfile') | (mode=='bidfile'):
        idfile = open(remainder[0],'r')
        idlines=idfile.read().splitlines()
        idlist=[]
        for line in idlines:
            idlist.extend([int(x) for x in line.split()])
        idlist=np.array(idlist)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+remainder[0]
    elif (mode=='mass') :
        mass_range = [float(x) for x in remainder[0].split('_')]
        if (len(mass_range)!=2):
            raise ValueError('Mass range should has a format of "min_max", ',remainder[0],' is given.')
        if (snap_type=='binary'):
            mass_range2 = [float(x) for x in remainder[1].split('_')]
            if (len(mass_range2)!=2):
                raise ValueError('Mass range should has a format of "min_max", ',remainder[1],' is given.')
        filename = remainder[1]
        filename_out = filename_prefix+'.m'+remainder[0]+'.'+snap_type
        if (snap_type=='binary'):     
            filename = remainder[2]
            filename_out = filename_prefix+'.m'+remainder[0]+'.m'+remainder[1]+'.'+snap_type
    elif (mode=='custom'):
        custom_script = remainder[0]
        selfun = __import__(custom_script)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+remainder[0]
    else:
        raise ValueError("Mode is not recognized, given ", mode, ", should be type, id, idfile, mass, bid, bidfile or custom.")

    if (output_format!='ascii'):
        write_option = write_option + 'b'
    print('Output file: ',filename_out)

    snap_kwargs=dict()
    snap_kwargs['interrupt_mode'] = interrupt_mode
    snap_kwargs['external_mode'] = external_mode
    snap_kwargs['snapshot_format'] = snapshot_format

    for key, item in kwargs.items(): print(key,':',item)

    fl = open(filename,'r')
    file_list = fl.read()
    path_list = file_list.splitlines()

    core = petar.Core()
    read_core = False
    if (cm_mode == 'core') | ((snap_type != 'origin') & (cm_mode == 'external')):
        core.loadtxt(core_file)
        read_core = True

    def select_type(_data, _type):
        sel = np.zeros(_data.size).astype(bool)
        for subtype in _type.split('_'):
            if (subtype[:2]=='no'):
                type_index = petar.BSE_STAR_TYPE_INDEX[subtype[2:]]
                sel = sel | (_data.star.type!=type_index)
            else:
                type_index = petar.BSE_STAR_TYPE_INDEX[subtype]
                sel = sel | (_data.star.type==type_index)
        return sel


    with open(filename_out, write_option) as f:
        for path in path_list:
            print('process ',path)
            header = petar.PeTarDataHeader(path, **snap_kwargs)
            time = header.time
            sel = np.array([])
            read_flag=False
            core_t = None
            if (read_core):
                core_t = core[(core.time==time)][0]

            if (snap_type=='binary'):
                p1_temp = petar.Particle(**snap_kwargs)
                p2_temp = petar.Particle(**snap_kwargs)
                data_temp=petar.Binary(p1_temp, p2_temp, **snap_kwargs)
                if os.path.getsize(path+'.binary')>0:
                    if (snapshot_format=='ascii'): 
                        data_temp.loadtxt(path+'.binary')
                    elif (snapshot_format=='binary'):
                        data_temp.fromfile(path+'.binary')
                    elif (snapshot_format=='npy'):
                        data_temp.load(path+'.binary.npy') 
                    else:
                        raise ValueError('Snapshot format %s unknown, should be ascii, binary or npy.' % snapshot_format)                        
                    if (mode=='custom'):
                        data_sel = selfun.petar_data_select_function(core_t, data_temp)
                    elif (external_mode!='none'): 
                        if (cm_mode=='external'):
                            data_temp.pos += core_t.pos
                            data_temp.vel += core_t.vel
                            data_temp.p1.pos += core_t.pos
                            data_temp.p2.pos += core_t.pos
                            data_temp.p1.vel += core_t.vel
                            data_temp.p2.vel += core_t.vel
                    if (mode=='type'):
                        sel1 = select_type(data_temp.p1, sse_type)
                        sel2 = select_type(data_temp.p2, sse_type2)
                        sel = sel1 & sel2
                     
                        sel1 = select_type(data_temp.p1, sse_type2)
                        sel2 = select_type(data_temp.p2, sse_type)
                        sel = sel | (sel1 & sel2)
                    elif (mode=='id') | (mode=='idfile'):
                        sel1 = np.in1d(data_temp.p1.id, idlist)
                        sel2 = np.in1d(data_temp.p2.id, idlist)
                        sel = sel1 | sel2
                    elif (mode=='bid') | (mode=='bidfile'):
                        data_temp.generateBinaryID()
                        sel = np.in1d(data_temp.bid, idlist)
                    elif (mode=='mass'):
                        sel1 = (data_temp.p1.mass >= mass_range[0]) & (data_temp.p1.mass < mass_range[1])
                        sel2 = (data_temp.p2.mass >= mass_range2[0]) & (data_temp.p2.mass < mass_range2[1])
                        sel = sel1 & sel2
 
                        sel1 = (data_temp.p2.mass >= mass_range[0]) & (data_temp.p2.mass < mass_range[1])
                        sel2 = (data_temp.p1.mass >= mass_range2[0]) & (data_temp.p1.mass < mass_range2[1])
                        sel = sel | (sel1 & sel2)
                    read_flag=True
                
            elif (snap_type=='single') | (snap_type=='origin'):
                data_temp=petar.Particle(**snap_kwargs)
                read_flag=False
                if (snapshot_format=='ascii'): 
                    if (snap_type=='origin'):
                        data_temp.loadtxt(path, skiprows=1)
                        read_flag=True
                    else:
                        if os.path.getsize(path+'.single')>0:
                            data_temp.loadtxt(path+'.single')
                            read_flag=True                            
                elif (snapshot_format=='binary'): 
                    if (snap_type=='origin'):
                        if (external_mode!='none'): 
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                        else:
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET)
                        read_flag=True
                    else:
                        if os.path.getsize(path+'.single')>0:
                            data_temp.fromfile(path+'.single')
                            read_flag=True
                elif (snapshot_format=='npy'): 
                    if (snap_type=='origin'):
                        if (external_mode!='none'): 
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                        else:
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET)
                        read_flag=True
                    else:
                        if os.path.getsize(path+'.single.npy')>0:
                            data_temp.load(path+'.single.npy')
                            read_flag=True
                else:
                    raise ValueError('Snapshot format %s unknown, should be ascii, binary or npy.' % snapshot_format)
                if (read_flag):
                    if (mode=='custom'):
                        if (snap_type=='origin'):
                            data_sel = selfun.petar_data_select_function(header, data_temp)
                        else:
                            data_sel = selfun.petar_data_select_function(core_t, data_temp)
                    elif (external_mode!='none'): 
                        if (cm_mode=='external'):
                            if (snap_type=='origin'):
                                data_temp.pos += header.pos_offset
                                data_temp.vel += header.vel_offset
                            else:
                                data_temp.pos += core_t.pos
                                data_temp.vel += core_t.vel
                        elif (cm_mode=='core'):
                            if (snap_type=='origin'):
                                data_temp.pos += header.pos_offset - core_t.pos
                                data_temp.vel += header.vel_offset - core_t.vel

                    if (mode=='type'):
                        sel = select_type(data_temp, sse_type)
                    elif (mode=='id') | (mode=='idfile'):
                        sel = np.in1d(data_temp.id, idlist)
                    elif (mode=='mass'):
                        sel = (data_temp.mass >= mass_range[0]) & (data_temp.mass < mass_range[1])

            elif (snap_type=='all') & (mode == 'custom'):
                p1_temp = petar.Particle(**snap_kwargs)
                p2_temp = petar.Particle(**snap_kwargs)
                binary=petar.Binary(p1_temp, p2_temp, **snap_kwargs)
                origin=petar.Particle(**snap_kwargs)
                single=petar.Particle(**snap_kwargs)
                if (snapshot_format=='ascii'): 
                    origin.loadtxt(path, skiprows=1)
                    if os.path.getsize(path+'.single')>0:
                        single.loadtxt(path+'.single')
                    if os.path.getsize(path+'.binary')>0:
                        binary.loadtxt(path+'.binary')
                elif (snapshot_format=='binary'): 
                    if (external_mode!='none'): 
                        origin.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                    else:
                        origin.fromfile(path, offset=petar.HEADER_OFFSET)
                    if os.path.getsize(path+'.single')>0:
                        single.fromfile(path+'.single')
                    if os.path.getsize(path+'.binary')>0:
                        binary.fromfile(path+'.binary')
                elif (snapshot_format=='npy'):
                    if (external_mode!='none'): 
                        origin.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                    else:
                        origin.fromfile(path, offset=petar.HEADER_OFFSET)
                    if os.path.getsize(path+'.single.npy')>0:
                        single.load(path+'.single.npy')
                    if os.path.getsize(path+'.binary')>0:
                        binary.load(path+'.binary.npy')
                else:
                    raise ValueError('Snapshot format %s is unknown, should be ascii, binary or npy.' % snapshot_format)                    
                        
                data_sel = selfun.petar_data_select_function(header, core_t, origin, single, binary)
                read_flag = True

            if(read_flag):
                if (mode != 'custom'):
                    data_sel = data_temp[sel]
                data_sel.addNewMember('time',(np.ones(data_sel.size)*time).astype(np.float64))
                if (output_format=='ascii'):
                    data_sel.savetxt(f)
                elif (output_format=='binary'):
                    data_sel.tofile(f)
                else:
                    raise ValueError('Output format %s is unknown, should be ascii, binary or npy.' % output_format)
                f.flush()
    
